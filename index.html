<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>五子棋/围棋/象棋人机对战</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f5f5f5;
            margin: 0;
            padding: 20px;
        }
        h1 {
            color: #333;
        }
        #game-selector {
            margin-bottom: 20px;
        }
        #game-selector button {
            padding: 10px 20px;
            margin: 0 10px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #ddd;
        }
        #game-selector button.active {
            background-color: #4CAF50;
            color: white;
        }
        #game-container {
            position: relative;
        }
        #board {
            border: 2px solid #333;
            background-color: #deb887; /* 木色背景 */
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        #status {
            margin-top: 20px;
            font-size: 18px;
            font-weight: bold;
            height: 25px;
        }
        #reset-btn {
            margin-top: 15px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #f44336;
            color: white;
        }
        #reset-btn:hover {
            background-color: #d32f2f;
        }
        /* 隐藏未选中的游戏 */
        .game-board {
            display: none;
        }
        .game-board.active {
            display: block;
        }
    </style>
</head>
<body>

<h1>五子棋/围棋/象棋人机对战</h1>

<div id="game-selector">
    <button class="game-btn active" data-game="gomoku">五子棋 (Gomoku)</button>
    <button class="game-btn" data-game="go">围棋 (Go) - 基础版</button>
    <button class="game-btn" data-game="xiangqi">象棋 (Xiangqi) - 基础版</button>
</div>

<div id="status">请选择游戏并开始。</div>
<button id="reset-btn">重置游戏</button>

<div id="game-container">
    <!-- 五子棋画布 -->
    <canvas id="gomoku-board" width="480" height="480" class="game-board active"></canvas>
    
    <!-- 围棋画布 -->
    <canvas id="go-board" width="520" height="520" class="game-board"></canvas>
    
    <!-- 象棋画布 -->
    <canvas id="xiangqi-board" width="540" height="600" class="game-board"></canvas>
</div>

<script>
    // --- 通用游戏逻辑 ---
    class Game {
        constructor() {
            this.currentGame = null;
            this.gameInstances = {};
            this.statusElement = document.getElementById('status');
            this.resetButton = document.getElementById('reset-btn');
            this.gameButtons = document.querySelectorAll('.game-btn');

            this.initGameButtons();
            this.resetButton.addEventListener('click', () => this.resetGame());
            // 默认启动五子棋
            this.switchGame('gomoku');
        }

        initGameButtons() {
            this.gameButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    const gameType = e.target.dataset.game;
                    this.switchGame(gameType);
                });
            });
        }

        switchGame(gameType) {
            // 更新按钮状态
            this.gameButtons.forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.game-btn[data-game="${gameType}"]`).classList.add('active');

            // 隐藏所有画布
            document.querySelectorAll('.game-board').forEach(canvas => canvas.classList.remove('active'));
            
            // 显示选中的画布
            const activeCanvas = document.getElementById(`${gameType}-board`);
            activeCanvas.classList.add('active');

            // 创建或切换游戏实例
            if (!this.gameInstances[gameType]) {
                if (gameType === 'gomoku') {
                    this.gameInstances[gameType] = new GomokuGame(activeCanvas, this);
                } else if (gameType === 'go') {
                    this.gameInstances[gameType] = new GoGame(activeCanvas, this);
                } else if (gameType === 'xiangqi') {
                    this.gameInstances[gameType] = new XiangqiGame(activeCanvas, this);
                }
            }
            this.currentGame = this.gameInstances[gameType];
            this.currentGame.init();
        }

        resetGame() {
            if (this.currentGame) {
                this.currentGame.reset();
            }
        }

        updateStatus(message) {
            this.statusElement.textContent = message;
        }
    }

    // --- 五子棋游戏逻辑 ---
    class GomokuGame {
        constructor(canvas, parentGame) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.parentGame = parentGame;
            this.size = 15; // 15x15 棋盘
            this.cellSize = canvas.width / (this.size - 1);
            this.board = [];
            this.gameOver = false;
            this.currentPlayer = 1; // 1 for black, -1 for white
            this.winner = 0;
            
            // AI settings
            this.aiPlayer = -1; // AI plays white
            this.searchDepth = 4; // AI search depth

            this.canvas.addEventListener('click', this.handleClick.bind(this));
        }

        init() {
            this.reset();
        }

        reset() {
            this.board = Array(this.size).fill().map(() => Array(this.size).fill(0));
            this.gameOver = false;
            this.currentPlayer = 1;
            this.winner = 0;
            this.parentGame.updateStatus("你的回合 (黑子)");
            this.drawBoard();
        }

        drawBoard() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            
            // Draw grid
            this.ctx.strokeStyle = '#000';
            this.ctx.lineWidth = 1;
            for (let i = 0; i < this.size; i++) {
                this.ctx.beginPath();
                this.ctx.moveTo(i * this.cellSize, 0);
                this.ctx.lineTo(i * this.cellSize, this.canvas.height);
                this.ctx.stroke();

                this.ctx.beginPath();
                this.ctx.moveTo(0, i * this.cellSize);
                this.ctx.lineTo(this.canvas.width, i * this.cellSize);
                this.ctx.stroke();
            }

            // Draw stars (hoshi) for 15x15 board
            const stars = [3, 7, 11];
            this.ctx.fillStyle = '#000';
            stars.forEach(i => {
                stars.forEach(j => {
                    this.ctx.beginPath();
                    this.ctx.arc(i * this.cellSize, j * this.cellSize, 4, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            });

            // Draw pieces
            for (let i = 0; i < this.size; i++) {
                for (let j = 0; j < this.size; j++) {
                    if (this.board[i][j] !== 0) {
                        this.ctx.beginPath();
                        this.ctx.arc(
                            i * this.cellSize,
                            j * this.cellSize,
                            this.cellSize / 2 - 2,
                            0,
                            Math.PI * 2
                        );
                        if (this.board[i][j] === 1) {
                            this.ctx.fillStyle = '#000'; // Black
                        } else {
                            this.ctx.fillStyle = '#fff'; // White
                        }
                        this.ctx.fill();
                        this.ctx.stroke();
                    }
                }
            }

            if (this.gameOver) {
                this.drawGameOver();
            }
        }

        drawGameOver() {
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.font = '30px Arial';
            this.ctx.fillStyle = '#000';
            let text = '';
            if (this.winner === 1) {
                text = '黑棋获胜!';
            } else if (this.winner === -1) {
                text = '白棋获胜!';
            } else {
                text = '平局!';
            }
            const textWidth = this.ctx.measureText(text).width;
            this.ctx.fillText(text, (this.canvas.width - textWidth) / 2, this.canvas.height / 2);
        }

        handleClick(e) {
            if (this.gameOver || this.currentPlayer !== 1) return;

            const rect = this.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const i = Math.round(x / this.cellSize);
            const j = Math.round(y / this.cellSize);

            if (i >= 0 && i < this.size && j >= 0 && j < this.size && this.board[i][j] === 0) {
                this.makeMove(i, j, this.currentPlayer);
                if (!this.gameOver) {
                    this.currentPlayer = -this.currentPlayer;
                    this.parentGame.updateStatus("AI 思考中... (白子)");
                    setTimeout(() => this.aiMove(), 300); // 稍微延迟，增加真实感
                }
            }
        }

        makeMove(x, y, player) {
            if (this.board[x][y] !== 0 || this.gameOver) return false;
            this.board[x][y] = player;
            this.drawBoard();
            if (this.checkWin(x, y, player)) {
                this.gameOver = true;
                this.winner = player;
                this.parentGame.updateStatus(player === 1 ? "黑棋获胜!" : "白棋获胜!");
                this.drawBoard();
                return true;
            }
            if (this.isBoardFull()) {
                this.gameOver = true;
                this.winner = 0; // Draw
                this.parentGame.updateStatus("平局!");
                this.drawBoard();
                return true;
            }
            return false;
        }

        isBoardFull() {
            for (let i = 0; i < this.size; i++) {
                for (let j = 0; j < this.size; j++) {
                    if (this.board[i][j] === 0) return false;
                }
            }
            return true;
        }

        checkWin(x, y, player) {
            const directions = [[1, 0], [0, 1], [1, 1], [1, -1]];
            for (let [dx, dy] of directions) {
                let count = 1;
                count += this.countDirection(x, y, dx, dy, player);
                count += this.countDirection(x, y, -dx, -dy, player);
                if (count >= 5) return true;
            }
            return false;
        }

        countDirection(x, y, dx, dy, player) {
            let count = 0;
            let tx = x + dx, ty = y + dy;
            while (tx >= 0 && tx < this.size && ty >= 0 && ty < this.size && this.board[tx][ty] === player) {
                count++;
                tx += dx;
                ty += dy;
            }
            return count;
        }

        aiMove() {
            if (this.gameOver) return;
            const move = this.getBestMove();
            if (move) {
                this.makeMove(move.x, move.y, this.aiPlayer);
                if (!this.gameOver) {
                    this.currentPlayer = -this.currentPlayer;
                    this.parentGame.updateStatus("你的回合 (黑子)");
                }
            }
        }

        getBestMove() {
            // Simple AI: Find a winning move, then block opponent, then random.
            // For a more advanced AI, implement minimax with alpha-beta pruning.
            
            // 1. Check for AI win
            for (let i = 0; i < this.size; i++) {
                for (let j = 0; j < this.size; j++) {
                    if (this.board[i][j] === 0) {
                        this.board[i][j] = this.aiPlayer;
                        if (this.checkWin(i, j, this.aiPlayer)) {
                            this.board[i][j] = 0;
                            return {x: i, y: j};
                        }
                        this.board[i][j] = 0;
                    }
                }
            }
            
            // 2. Check for blocking opponent win
            const opponent = -this.aiPlayer;
            for (let i = 0; i < this.size; i++) {
                for (let j = 0; j < this.size; j++) {
                    if (this.board[i][j] === 0) {
                        this.board[i][j] = opponent;
                        if (this.checkWin(i, j, opponent)) {
                            this.board[i][j] = 0;
                            return {x: i, y: j};
                        }
                        this.board[i][j] = 0;
                    }
                }
            }
            
            // 3. Basic heuristic: prefer center and moves that create potential
            let bestScore = -Infinity;
            let bestMoves = [];
            for (let i = 0; i < this.size; i++) {
                for (let j = 0; j < this.size; j++) {
                    if (this.board[i][j] === 0) {
                        const score = this.evaluateMove(i, j, this.aiPlayer) + this.evaluateMove(i, j, opponent);
                        if (score > bestScore) {
                            bestScore = score;
                            bestMoves = [{x: i, y: j}];
                        } else if (score === bestScore) {
                            bestMoves.push({x: i, y: j});
                        }
                    }
                }
            }
            
            if (bestMoves.length > 0) {
                return bestMoves[Math.floor(Math.random() * bestMoves.length)];
            }

            // 4. Fallback to random
            const emptyCells = [];
            for (let i = 0; i < this.size; i++) {
                for (let j = 0; j < this.size; j++) {
                    if (this.board[i][j] === 0) {
                        emptyCells.push({x: i, y: j});
                    }
                }
            }
            if (emptyCells.length > 0) {
                return emptyCells[Math.floor(Math.random() * emptyCells.length)];
            }
            return null;
        }

        evaluateMove(x, y, player) {
            if (this.board[x][y] !== 0) return -Infinity;
            
            let score = 0;
            const directions = [[1, 0], [0, 1], [1, 1], [1, -1]];
            
            // Prefer center
            const center = (this.size - 1) / 2;
            score -= Math.abs(x - center) + Math.abs(y - center);
            
            // Evaluate potential in each direction
            for (let [dx, dy] of directions) {
                let count = 0;
                let blocked = 0;
                
                let tx = x + dx, ty = y + dy;
                while (tx >= 0 && tx < this.size && ty >= 0 && ty < this.size) {
                    if (this.board[tx][ty] === player) {
                        count++;
                    } else if (this.board[tx][ty] === -player) {
                        blocked++;
                        break;
                    } else {
                        break;
                    }
                    tx += dx;
                    ty += dy;
                }
                
                tx = x - dx; ty = y - dy;
                while (tx >= 0 && tx < this.size && ty >= 0 && ty < this.size) {
                    if (this.board[tx][ty] === player) {
                        count++;
                    } else if (this.board[tx][ty] === -player) {
                        blocked++;
                        break;
                    } else {
                        break;
                    }
                    tx -= dx;
                    ty -= dy;
                }
                
                if (count >= 4) score += 10000;
                else if (count === 3 && blocked === 0) score += 1000;
                else if (count === 3 && blocked === 1) score += 100;
                else if (count === 2 && blocked === 0) score += 10;
                else if (count === 2 && blocked === 1) score += 1;
            }
            return score;
        }
    }

    // --- 围棋游戏逻辑 (基础版) ---
    class GoGame {
        constructor(canvas, parentGame) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.parentGame = parentGame;
            this.size = 19; // 19x19 棋盘
            this.cellSize = canvas.width / (this.size - 1);
            this.board = [];
            this.gameOver = false;
            this.currentPlayer = 1; // 1 for black, -1 for white
            this.captured = {1: 0, '-1': 0}; // Captured stones count

            // AI settings
            this.aiPlayer = -1; // AI plays white
            // 简单AI，随机下子
            this.simpleAI = true;

            this.canvas.addEventListener('click', this.handleClick.bind(this));
        }

        init() {
            this.reset();
        }

        reset() {
            this.board = Array(this.size).fill().map(() => Array(this.size).fill(0));
            this.gameOver = false;
            this.currentPlayer = 1;
            this.captured = {1: 0, '-1': 0};
            this.parentGame.updateStatus("围棋 - 你的回合 (黑子)");
            this.drawBoard();
        }

        drawBoard() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            
            // Draw grid
            this.ctx.strokeStyle = '#000';
            this.ctx.lineWidth = 1;
            for (let i = 0; i < this.size; i++) {
                this.ctx.beginPath();
                this.ctx.moveTo(i * this.cellSize, 0);
                this.ctx.lineTo(i * this.cellSize, this.canvas.height);
                this.ctx.stroke();

                this.ctx.beginPath();
                this.ctx.moveTo(0, i * this.cellSize);
                this.ctx.lineTo(this.canvas.width, i * this.cellSize);
                this.ctx.stroke();
            }

            // Draw stars (hoshi) for 19x19 board
            const stars = [3, 9, 15];
            this.ctx.fillStyle = '#000';
            stars.forEach(i => {
                stars.forEach(j => {
                    this.ctx.beginPath();
                    this.ctx.arc(i * this.cellSize, j * this.cellSize, 4, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            });

            // Draw pieces
            for (let i = 0; i < this.size; i++) {
                for (let j = 0; j < this.size; j++) {
                    if (this.board[i][j] !== 0) {
                        this.ctx.beginPath();
                        this.ctx.arc(
                            i * this.cellSize,
                            j * this.cellSize,
                            this.cellSize / 2 - 2,
                            0,
                            Math.PI * 2
                        );
                        if (this.board[i][j] === 1) {
                            this.ctx.fillStyle = '#000'; // Black
                        } else {
                            this.ctx.fillStyle = '#fff'; // White
                        }
                        this.ctx.fill();
                        this.ctx.stroke();
                    }
                }
            }

            if (this.gameOver) {
                this.drawGameOver();
            }
        }

        drawGameOver() {
            // 简单显示，实际围棋需要计算目数
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.font = '30px Arial';
            this.ctx.fillStyle = '#000';
            const text = '围棋游戏结束 (基础版)';
            const textWidth = this.ctx.measureText(text).width;
            this.ctx.fillText(text, (this.canvas.width - textWidth) / 2, this.canvas.height / 2);
        }

        handleClick(e) {
            if (this.gameOver || this.currentPlayer !== 1) return;

            const rect = this.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const i = Math.round(x / this.cellSize);
            const j = Math.round(y / this.cellSize);

            if (i >= 0 && i < this.size && j >= 0 && j < this.size && this.board[i][j] === 0) {
                 // Simple place, no capture logic in this basic version
                 this.board[i][j] = this.currentPlayer;
                 this.drawBoard();
                 this.currentPlayer = -this.currentPlayer;
                 this.parentGame.updateStatus("AI 思考中... (白子)");
                 setTimeout(() => this.aiMove(), 300);
            }
        }

        aiMove() {
            if (this.gameOver) return;
            // Very simple AI: random valid move
            const emptyCells = [];
            for (let i = 0; i < this.size; i++) {
                for (let j = 0; j < this.size; j++) {
                    if (this.board[i][j] === 0) {
                        emptyCells.push({x: i, y: j});
                    }
                }
            }
            if (emptyCells.length > 0) {
                const move = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                this.board[move.x][move.y] = this.aiPlayer;
                this.drawBoard();
                this.currentPlayer = -this.currentPlayer;
                this.parentGame.updateStatus("你的回合 (黑子)");
            }
        }
    }

    // --- 象棋游戏逻辑 (基础版) ---
    class XiangqiGame {
        constructor(canvas, parentGame) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.parentGame = parentGroup;
            this.rows = 10;
            this.cols = 9;
            this.cellSize = canvas.width / (this.cols - 1);
            this.board = [];
            this.gameOver = false;
            this.currentPlayer = 1; // 1 for red, -1 for black

            // AI settings
            this.aiPlayer = -1; // AI plays black
            // 简单AI，随机移动
            this.simpleAI = true;

            this.canvas.addEventListener('click', this.handleClick.bind(this));
            
            // Piece symbols (using Unicode characters for simplicity)
            this.pieces = {
                'R': '帥', 'r': '將', // General
                'A': '仕', 'a': '士', // Advisor
                'B': '相', 'b': '象', // Bishop
                'N': '傌', 'n': '馬', // Knight
                'C': '炮', 'c': '砲', // Cannon
                'P': '兵', 'p': '卒'  // Pawn
            };
        }

        init() {
            this.reset();
        }

        reset() {
            this.initBoard();
            this.gameOver = false;
            this.currentPlayer = 1;
            this.parentGame.updateStatus("象棋 - 你的回合 (红方)");
            this.drawBoard();
        }

        initBoard() {
             // Initial setup for Xiangqi
            this.board = Array(this.rows).fill().map(() => Array(this.cols).fill(null));
            
            // Black pieces (top)
            this.board[0] = ['r', 'n', 'b', 'a', 'c', 'a', 'b', 'n', 'r'];
            this.board[2][1] = 'n'; this.board[2][7] = 'n'; // Knights
            this.board[3] = [null, 'p', null, 'p', null, 'p', null, 'p', null]; // Pawns

            // Red pieces (bottom)
            this.board[9] = ['R', 'N', 'B', 'A', 'C', 'A', 'B', 'N', 'R'];
            this.board[7][1] = 'N'; this.board[7][7] = 'N'; // Knights
            this.board[6] = [null, 'P', null, 'P', null, 'P', null, 'P', null]; // Pawns
            
            // Cannons
            this.board[2][1] = 'n'; this.board[2][7] = 'n'; // Overwrite knights for cannons
            this.board[0][1] = 'c'; this.board[0][7] = 'c'; // Black cannons
            this.board[7][1] = 'N'; this.board[7][7] = 'N'; // Overwrite knights for cannons
            this.board[9][1] = 'C'; this.board[9][7] = 'C'; // Red cannons
        }

        drawBoard() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            
            // Draw grid
            this.ctx.strokeStyle = '#000';
            this.ctx.lineWidth = 1;
            
            // Vertical lines
            for (let i = 0; i < this.cols; i++) {
                this.ctx.beginPath();
                // Full line for most columns
                if (i === 0 || i === this.cols - 1 || (i > 0 && i < this.cols - 1)) {
                     this.ctx.moveTo(i * this.cellSize, 0);
                     this.ctx.lineTo(i * this.cellSize, 9 * this.cellSize); // Main board
                     
                     // Palace lines
                     if (i >= 3 && i <= 5) {
                         // Black palace
                         if(i<5) {
                             this.ctx.moveTo(i * this.cellSize, 0);
                             this.ctx.lineTo((i+1) * this.cellSize, 1 * this.cellSize);
                             this.ctx.moveTo((i+1) * this.cellSize, 0);
                             this.ctx.lineTo(i * this.cellSize, 1 * this.cellSize);
                         }
                         // Red palace
                         if(i>3) {
                             this.ctx.moveTo(i * this.cellSize, 9 * this.cellSize);
                             this.ctx.lineTo((i-1) * this.cellSize, 8 * this.cellSize);
                             this.ctx.moveTo((i-1) * this.cellSize, 9 * this.cellSize);
                             this.ctx.lineTo(i * this.cellSize, 8 * this.cellSize);
                         }
                     }
                }
                this.ctx.stroke();
            }
            
            // Horizontal lines
            for (let j = 0; j < this.rows; j++) {
                this.ctx.beginPath();
                if (j <= 4) { // Black side
                    this.ctx.moveTo(0, j * this.cellSize);
                    this.ctx.lineTo(8 * this.cellSize, j * this.cellSize);
                } else if (j >= 5) { // Red side
                    this.ctx.moveTo(0, j * this.cellSize);
                    this.ctx.lineTo(8 * this.cellSize, j * this.cellSize);
                }
                this.ctx.stroke();
            }
            
            // River
            this.ctx.font = '20px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            this.ctx.fillStyle = '#000';
            this.ctx.fillText('楚 河', 2 * this.cellSize, 4.5 * this.cellSize);
            this.ctx.fillText('汉 界', 6 * this.cellSize, 4.5 * this.cellSize);

            // Draw pieces
            this.ctx.font = '24px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            for (let i = 0; i < this.rows; i++) {
                for (let j = 0; j < this.cols; j++) {
                    const piece = this.board[i][j];
                    if (piece) {
                        const x = j * this.cellSize;
                        const y = i * this.cellSize;
                        this.ctx.fillStyle = (piece === piece.toUpperCase()) ? '#red' : '#000'; // Red for uppercase
                        // Fix color string
                        this.ctx.fillStyle = (piece === piece.toUpperCase()) ? '#FF0000' : '#000000';
                        this.ctx.fillText(this.pieces[piece], x, y);
                    }
                }
            }

            if (this.gameOver) {
                this.drawGameOver();
            }
        }

        drawGameOver() {
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.font = '30px Arial';
            this.ctx.fillStyle = '#000';
            const text = '象棋游戏结束 (基础版)';
            const textWidth = this.ctx.measureText(text).width;
            this.ctx.fillText(text, (this.canvas.width - textWidth) / 2, this.canvas.height / 2);
        }

        handleClick(e) {
             if (this.gameOver || this.currentPlayer !== 1) return;

            const rect = this.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const j = Math.round(x / this.cellSize); // col
            const i = Math.round(y / this.cellSize); // row

            if (i >= 0 && i < this.rows && j >= 0 && j < this.cols) {
                 // Simple place, no movement logic in this basic version
                 console.log(`Clicked on row ${i}, col ${j}. Piece: ${this.board[i][j]}`);
                 this.parentGame.updateStatus(`点击了 (${i}, ${j})`);
                 // Trigger AI move for demo
                 setTimeout(() => this.aiMove(), 300);
            }
        }

        aiMove() {
            if (this.gameOver) return;
            // Very simple AI: do nothing in this basic version
            // Just switch player back to human
            this.currentPlayer = -this.currentPlayer;
            this.parentGame.updateStatus("你的回合 (红方)");
            // Or make a random move if logic was implemented
            /*
            const movablePieces = [];
            for (let i = 0; i < this.rows; i++) {
                for (let j = 0; j < this.cols; j++) {
                    if (this.board[i][j] && this.board[i][j] === this.aiPlayer) {
                         // Find valid moves for this piece (not implemented here)
                         // movablePieces.push({row: i, col: j, moves: [...]});
                    }
                }
            }
            if (movablePieces.length > 0) {
                // Choose a piece and a move
                this.board[...][...] = ...; // Make move
                this.drawBoard();
                this.currentPlayer = -this.currentPlayer;
                this.parentGame.updateStatus("你的回合 (红方)");
            }
            */
        }
    }

    // --- 初始化游戏 ---
    window.onload = () => {
        new Game();
    };
</script>

</body>
</html>



